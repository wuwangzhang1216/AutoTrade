function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
import { visit } from 'unist-util-visit';
var DEFAULT_ALLOW_HTML_TAGS = ['sub', 'sup', 'ins', 'kbd', 'b', 'strong', 'i', 'em', 'mark', 'del', 'u'];
export var remarkGfmPlus = function remarkGfmPlus() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _options$allowHtmlTag = options.allowHtmlTags,
    allowHtmlTags = _options$allowHtmlTag === void 0 ? DEFAULT_ALLOW_HTML_TAGS : _options$allowHtmlTag;
  return function (tree) {
    // 遍历所有父节点，查找分离的HTML标签模式
    visit(tree, function (node) {
      if (!node.children || !Array.isArray(node.children)) return;
      var children = node.children;
      var i = 0;
      while (i < children.length) {
        var currentNode = children[i];

        // 查找开始标签
        if (currentNode.type === 'html' && currentNode.value) {
          var tagPattern = "^<(".concat(allowHtmlTags.join('|'), ")>$");
          var startTagMatch = currentNode.value.match(new RegExp(tagPattern));
          if (startTagMatch) {
            var tagName = startTagMatch[1];

            // 查找对应的结束标签
            var endIndex = -1;
            var textNodes = [];
            for (var j = i + 1; j < children.length; j++) {
              var nextNode = children[j];
              if (nextNode.type === 'html' && nextNode.value === "</".concat(tagName, ">")) {
                endIndex = j;
                break;
              } else if (nextNode.type === 'text') {
                textNodes.push(nextNode);
              } else {
                // 如果遇到其他类型的节点，停止查找
                break;
              }
            }
            if (endIndex !== -1) {
              // 收集所有文本内容
              var textContent = textNodes.map(function (node) {
                return node.value;
              }).join('');

              // 创建新的自定义节点
              var newNode = {
                children: [{
                  type: 'text',
                  value: textContent
                }],
                data: {
                  hName: tagName,
                  hProperties: {}
                },
                type: tagName
              };

              // 替换从开始标签到结束标签的所有节点
              var removeCount = endIndex - i + 1;
              children.splice(i, removeCount, newNode);

              // 继续处理下一个节点
              i++;
              continue;
            }
          }
        }
        i++;
      }
    });

    // 保留对文本节点中完整HTML标签的处理（作为备用）
    visit(tree, 'text', function (node) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var parent = arguments.length > 2 ? arguments[2] : undefined;
      if (!node.value || typeof node.value !== 'string') return;

      // 处理HTML实体编码的标签
      var encodedTagPattern = "&lt;(".concat(allowHtmlTags.join('|'), ")&gt;(.*?)&lt;\\/\\1&gt;");
      var encodedTagRegex = new RegExp(encodedTagPattern, 'gi');
      var text = node.value;
      if (!encodedTagRegex.test(text)) return;

      // 重置正则表达式的 lastIndex
      encodedTagRegex.lastIndex = 0;
      var newNodes = [];
      var lastIndex = 0;
      var match;
      while ((match = encodedTagRegex.exec(text)) !== null) {
        var _match = match,
          _match2 = _slicedToArray(_match, 3),
          fullMatch = _match2[0],
          tagName = _match2[1],
          content = _match2[2];
        var startIndex = match.index;

        // 添加匹配前的文本
        if (startIndex > lastIndex) {
          newNodes.push({
            type: 'text',
            value: text.slice(lastIndex, startIndex)
          });
        }

        // 添加特殊标签节点
        newNodes.push({
          children: [{
            type: 'text',
            value: content
          }],
          data: {
            hName: tagName,
            hProperties: {}
          },
          type: tagName
        });
        lastIndex = startIndex + fullMatch.length;
      }

      // 添加剩余文本
      if (lastIndex < text.length) {
        newNodes.push({
          type: 'text',
          value: text.slice(lastIndex)
        });
      }

      // 替换当前节点
      if (newNodes.length > 0 && parent) {
        var _parent$children;
        (_parent$children = parent.children).splice.apply(_parent$children, [index, 1].concat(newNodes));
        return index + newNodes.length - 1;
      }
    });
  };
};